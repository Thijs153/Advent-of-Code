using System.Collections.Concurrent;

namespace AOC._2024;

using Cache = ConcurrentDictionary<(string, int), long>;

public class Day11
{
    private readonly string _input = File.ReadAllText("Inputs/Day11.txt");

    [Fact]
    public void Part1() => StoneCount(_input, 25).Should().Be(184927L);

    [Fact]
    public void Part2() => StoneCount(_input, 75).Should().Be(220357186726677L);
    
    private static long StoneCount(string input, int blinks)
    {
        var cache = new Cache();
        return input.Split(" ").Sum(n => Eval(long.Parse(n), blinks, cache));
    }
    
    /*
     * Recursively calculates the total number of stones generated by a single engraving
     * after a specified number of blinks. Uses caching to optimize and prevent exponential
     * computation by storing intermediate results.
     */
    private static long Eval(long engraving, int blinks, Cache cache) =>
        cache.GetOrAdd((engraving.ToString(), blinks), static (key, args) =>
            key switch
            {
                (_, 0) => 1,

                ("0", _) => Eval(1, args.blinks - 1, args.cache),

                var (st, _) when st.Length % 2 == 0 =>
                    Eval(long.Parse(st[..(st.Length / 2)]), args.blinks - 1, args.cache) +
                    Eval(long.Parse(st[(st.Length / 2)..]), args.blinks - 1, args.cache),

                _ => Eval(2024 * args.engraving, args.blinks - 1, args.cache)
            },
            (engraving, blinks, cache)
        );
}